<!DOCTYPE HTML>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    

    <title>新一代构建工具Gradle | 记录学习的技能和遇到的问题</title>
    <meta name="author" content="伊始雨深">
    
    <meta name="description" content="#####导语：

随着技术的发展，不管是前端开发、服务端开发或者是移动端开发（移动也是前端的一个分支）中都会用到自动化构建工具。如果我们没有使用过自动化构建工具，可能对自动构建工具没有什么概念，为什么需要用到自动化构建工具。我们先来看一下在没有使用自动化构建工具前，我们是如何开发项目、管理项目的。">
    
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta property="og:title" content="新一代构建工具Gradle"/>
    <meta property="og:site_name" content="伊始雨深的博客"/>

    
    <meta property="og:image" content="undefined"/>
    

    <link rel="icon" type="image/png" href="/favicon.png">
    <link rel="alternate" href="/atom.xml" title="伊始雨深的博客" type="application/atom+xml">
    <link rel="stylesheet" href="/css/lib/materialize.min.css">
    <link rel="stylesheet" href="/css/lib/font-awesome.min.css">
    <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

    
        <link rel="stylesheet" href="/css/lib/prettify-tomorrow-night-eighties.css" type="text/css">
    
    <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
</head>


<body>
    <img src="/weixin_favicon.png" style="position: absolute; left: -9999px; opacity: 0; filter: alpha(opacity=0);">

    <nav class="indigo">
    <div class="nav-wrapper">
        <a href="#" data-activates="main-menu" class="button-collapse">
            <i class="fa fa-navicon"></i>
        </a>
        <div class="">
            <a href="/" class="brand-logo hide-on-med-and-down">伊始雨深的博客</a>
            <ul class="right hide-on-med-and-down">
                
                    <li>
                        <a class="menu-home " href="/" >
                            <i class="fa fa-home "></i>
                            
                            首页
                        </a>
                    </li>
                
                    <li>
                        <a class="menu-archive " href="/archives" >
                            <i class="fa fa-archive "></i>
                            
                            归档
                        </a>
                    </li>
                
                    <li>
                        <a class="menu-category category-menu" href="javascript:;" data-activates="category-menu" >
                            <i class="fa fa-bookmark "></i>
                            
                            分类
                        </a>
                    </li>
                
                    <li>
                        <a class="menu-reading " href="/reading" >
                            <i class="fa fa-book "></i>
                            
                            读书
                        </a>
                    </li>
                
                    <li>
                        <a class="menu-about " href="/about" >
                            <i class="fa fa-user "></i>
                            
                            关于
                        </a>
                    </li>
                
                    <li>
                        <a class="menu-search modal-trigger " href="#search" >
                            <i class="fa fa-search "></i>
                            
                            搜索
                        </a>
                    </li>
                
            </ul>
            <div>
    <ul class="side-nav indigo darken-1" id="main-menu">
        
        <li class="side-user">
            <div class="row">
                <div class="col s4 no-padding">
                    <img class="avatar-image circle responsive-img" src="http://note.youdao.com/yws/public/resource/c6e9ec6ca0d984a33902c5a26b0c09e9/xmlnote/0618F6E2F0264AE48FF2872932A60CDD/783" alt="User Avatar">
                </div>
                <div class="info col s8 valign-wrapper no-padding">
                    <div class="valign">
                        <p class="name">伊始雨深</p>
                        <p class="desc">Android/Web前端/Java/后端</p>
                    </div>
                </div>
            </div>
        </li>
        

        
            <li class="no-padding">
                <a class="waves-effect menu-home " href="/" >
                    <i class="fa fa-home "></i>
                    
                    首页
                </a>
            </li>
        
            <li class="no-padding">
                <a class="waves-effect menu-archive " href="/archives" >
                    <i class="fa fa-archive "></i>
                    
                    归档
                </a>
            </li>
        
            <li class="no-padding">
                <a class="waves-effect menu-category category-menu" href="javascript:;" data-activates="category-menu" >
                    <i class="fa fa-bookmark "></i>
                    
                    分类
                </a>
            </li>
        
            <li class="no-padding">
                <a class="waves-effect menu-reading " href="/reading" >
                    <i class="fa fa-book "></i>
                    
                    读书
                </a>
            </li>
        
            <li class="no-padding">
                <a class="waves-effect menu-about " href="/about" >
                    <i class="fa fa-user "></i>
                    
                    关于
                </a>
            </li>
        
            <li class="no-padding">
                <a class="waves-effect menu-search modal-trigger " href="#search" >
                    <i class="fa fa-search "></i>
                    
                    搜索
                </a>
            </li>
        
    </ul>

    <ul class="side-nav indigo darken-1" id="category-menu">
    

            

            <li class="collapse-level-0" collapse-level="0">
                <a class="no-padding" href="/categories/Android/">
                    Android <span class="right">1 篇</span></a>
                </a>
            </li>

        

    </ul>
</div>

        </div>
    </div>
</nav>

<div id="search" class="modal search-modal">
    <div class="row">
        <div class="input-field col s12">
              <input id="search-input" type="text">
              <label for="search-input">搜索</label>
        </div>

    </div>
    <div id="search-result" class="search-result col s12">

    </div>
</div>


    <main>
        <div class="container main-container">
    <nav class="page-nav hide-on-small-only">
    <div class="nav-wrapper indigo">
        <span class="breadcrumb">当前位置（分类目录）</span>
        
            
    
    
    <a class="breadcrumb" href="/categories/Android/">Android</a>


        

        
    </div>
</nav>

<article>
    <div class="card">
        <div class="card-content">
            

            <div class="article-title">
                
    
        <h1>新一代构建工具Gradle</h1>
    


            </div>
            <time class="pink-link-context" datetime="2017-06-18T14:38:16.000Z"><a href="/2017/06/18/新一代构建工具Gradle/">2017-06-18</a></time>

            <span id="busuanzi_container_page_pv" class="read-times-container">
    <i class="fa fa-eye"></i>
    <span id="busuanzi_value_page_pv"></span>
</span>

            
    <div class="tags-row">
        
            <a href="/tags/Gradle/" class="chip pink lighten-1">Gradle</a>
        
    </div>


            <div class="toc pink-link-context hide-on-med-and-down">
    
</div>


            <div class="entry pink-link-context">
                <p>  #####导语：</p>
<blockquote>
<p>随着技术的发展，不管是前端开发、服务端开发或者是移动端开发（移动也是前端的一个分支）中都会用到自动化构建工具。如果我们没有使用过自动化构建工具，可能对自动构建工具没有什么概念，为什么需要用到自动化构建工具。我们先来看一下在没有使用自动化构建工具前，我们是如何开发项目、管理项目的。项目开发过程中涉及新建项目-》代码开发—》依赖管理-》编译-》测试-》打包-》上传等过程。依赖管理，项目开发过程中会用到很多jar包，自己开发的有别人开发的，这些都放在项目的lib目录。大点的项目几百个，很容易造成依赖冲突，另外就是版本更新特别不方便，你得手动去复制新版本的jar包放到lib目录下。测试过程，大家都不重视，基本上写一个java类，在main方法调用调试几下就完了。打包，得手动，如在Eclipse上导出jar包，web开发的话导出war包。另外发布不同版本，还得手动去更改后才能打出自己想要的。上传过程中，得手动或用ftp上传到服务器上面。这些过程太频繁、琐碎无聊，小点项目还能管理的过来，大的项目简直是灾难。技术大牛们忍无可忍总于爆发了，发明出了构建工具这个东西，将程序员们从水深火热中解脱出来。</p>
</blockquote>
<p>##构建工具的作用</p>
<ul>
<li>依赖管理</li>
<li>自动测试、自动打包、自动发布到制定的地方去</li>
<li>机器能干的，我们绝不自己动手</li>
</ul>
<p>##Java方面主流的构建工具</p>
<ul>
<li>最早出现的Ant，提供了编译、测试、打包三个最基本的功能</li>
<li>接着Maven,在Ant的基础上加了依赖管理和发布功能，通过xml标记性语言来进行管理构建脚步</li>
<li>接着重点来了，我们要学习的Gradle，它在Maven基础上更近一步，使用Groovy进行管理构建脚步，不再使用xml ，因为项目大了之后使用xml很容易造成啰唆、臃肿难以管理。而使用这种特定领域语言来管理构建脚步具有更高的可拓展性和灵活性。</li>
</ul>
<p>##Gradle是什么<br>  一个开源的项目自动化构建工具，建立在Apache Ant 和 Apache Maven概念的基础上，并引入了基于Groovy的特定领域语言（DSL），而不再使用xml形式的管理构建脚本。</p>
<p>##Gradle的作用，即能为我们做什么<br> Gradle是一个项目自动化构建工具，它当然具备自动化构建的所有功能，依赖管理，自动化测试、自动化打包，发布到制定的地方去。另外它具有很高的拓展性和灵活性，你想要它做什么，它都能帮你完成。</p>
<p>###准备使用Gradle<br>  Gradle的安装、配置环境变量<br>  1. 因为Gradle是基于JVM的所以确保本地安装了JDK  java -version<br>  2. 打开官网下载安装包，解压到制定的目录Gradle官网<a href="https://gradle.org/docs#getting-started" target="_blank" rel="external">https://gradle.org/docs#getting-started</a><br>  3. 配置环境变量，GRADLE_HOME添加到path中，%GRADLE_HOME%\bin;<br>  4. 验证是否安装成功，gradle -v</p>
<p>##groovy语言基础知识<br>  <strong>Groovy是什么</strong><br>  Groovy是用Java虚拟机的一种敏捷的动态语言，它是一种成熟的面向对象编程语言，即可用于面向对象编程，又可以用作纯粹的脚本语言。使用该语言不需要编写太多的代码，同时又具有闭包和动态语言中的其他特性。<br>下面的知识点都可以到官网文档中查询到<a href="http://www.groovy-lang.org/documentation.html" target="_blank" rel="external">http://www.groovy-lang.org/documentation.html</a><br>  <strong>与java相比</strong><br>            1、Groovy完全兼容java语法，最终也编译成字节码<br>            2、Groovy注释标记和Java一样，支持//或者//<br>            3、Groovy中支持动态类型，即定义变量的时候可以不指定其类型。<br>            4、Groovy中，变量定义可以使用关键字def。注意，虽然def不是必须的，但是为了代码清晰，建议还是使用def关键字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def var =1 </div><div class="line">def str= &quot;i am a person&quot;</div><div class="line">def int x = 1//也可以指定类型</div></pre></td></tr></table></figure></p>
<p>    5、函数定义时，参数的类型也可以不指定。比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">String function(arg1,args2)&#123;//无需指定参数类型</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  6、除了变量定义可以不指定类型外，Groovy中函数的返回值也可以是无类型的。<br>        比如：//无类型的函数定义，必须使用def关键字<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def  nonReturnTypeFunc()&#123;</div><div class="line">     last_line   //最后一行代码的执行结果就是本函数的返回值</div><div class="line">&#125;</div><div class="line">//如果指定了函数返回类型，则可不必加def关键字来定义函数</div><div class="line">String  getString()&#123;</div><div class="line">   return &quot;I am a string&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实，所谓的无返回类型的函数，我估计内部都是按返回Object类型来处理的。毕竟，Groovy是基于Java的，而且最终会转成Java Code运行在JVM上。<br>  7、 函数返回值：Groovy的函数里，可以不使用return xxx来设置xxx为函数返回值。如果不使用return语句的话，则函数里最后一句代码的执行结果被设置成返回值。比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">//下面这个函数的返回值是字符串&quot;getSomething return value&quot;</div><div class="line">def getSomething()&#123;</div><div class="line">   &quot;getSomething return value&quot; //如果这是最后一行代码，则返回类型为String</div><div class="line">    1000 //如果这是最后一行代码，则返回类型为Integer</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意，如果函数定义时候指明了返回值类型的话，函数中则必须返回正确的数据类型,否则运行时报错。如果使用了动态类型的话，你就可以返回任何类型了。<br>  8、Groovy对字符串支持相当强大，充分吸收了一些脚本语言的优点：单引号’’中的内容严格对应Java中的String，不对$符号进行转义<br><code>def singleQuote=&#39;I am $ dolloar&#39;  //输出就是I am $ dolloar</code><br>双引号””的内容则和脚本语言的处理有点像，如果字符中有$号的话，则它会$表达式先求值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def doubleQuoteWithoutDollar = &quot;I am one dollar&quot; //输出 I am one dollar</div><div class="line">def x = 1</div><div class="line">def doubleQuoteWithDollar = &quot;I am $x dolloar&quot; //输出I am 1 dolloar</div></pre></td></tr></table></figure></p>
<p>三个引号’’’xxx’’’中的字符串支持随意换行 比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def multieLines = &apos;&apos;&apos; begin</div><div class="line">   line  1 </div><div class="line">   line  2</div><div class="line">   end &apos;&apos;&apos;</div></pre></td></tr></table></figure></p>
<p>  9、 Groovy语句可以不用分号结尾。Groovy为了尽量减少代码的输入，确实煞费苦心<br>  10、除了每行代码不用加分号外，Groovy中函数调用的时候还可以不加括号。比如：<br><code>println(&quot;test&quot;) ---&gt; println &quot;test&quot;</code><br>注意，虽然写代码的时候，对于函数调用可以不带括号，但是Groovy经常把属性和函数调用混淆。比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def getSomething()&#123;</div><div class="line">   &quot;hello&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>getSomething() //如果不加括号的话，Groovy会误认为getSomething是一个变量。<br>  <strong>数据类型的不同</strong><br>     Groovy中的数据类型我们就介绍两种和Java不太一样的：<br>    一个是Java中的基本数据类型。<br>     另外一个是Groovy中的容器类。<br>    最后一个非常重要的是闭包。<br>    <strong>基本数据类型</strong><br>    作为动态语言，Groovy世界中的所有事物都是对象。所以，int，boolean这些Java中的基本数据类型，在Groovy代码中其实对应的是它们的包装数据类型。比如int对应为Integer，boolean对应为Boolean。比如下图中的代码执行结果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4002556-17daef6effa93cb7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img0.png"><br>   <strong>容器类</strong><br>   List类其实是ArrayList类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">变量定义：List变量由[]定义，比如</div><div class="line"></div><div class="line">def aList = [5,&apos;string&apos;,true] //List由[]定义，其元素可以是任何对象</div><div class="line"></div><div class="line">变量存取：可以直接通过索引存取，而且不用担心索引越界。如果索引超过当前链表长度，List会自动</div><div class="line">往该索引添加元素</div><div class="line"></div><div class="line">assert aList[1] == &apos;string&apos;</div><div class="line">assert aList[5] == null //第6个元素为空</div><div class="line">aList[100] = 100  //设置第101个元素的值为10</div><div class="line">assert aList[100] == 100</div><div class="line"></div><div class="line">那么，aList到现在为止有多少个元素呢？</div><div class="line">println aList.size  ===&gt;结果是101</div></pre></td></tr></table></figure></p>
<p>  <strong>Map类其实是LinkedHashMap类</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">容器变量定义</div><div class="line"></div><div class="line">变量定义：Map变量由[:]定义，比如</div><div class="line"></div><div class="line">def aMap = [&apos;key1&apos;:&apos;value1&apos;,&apos;key2&apos;:true] </div><div class="line"></div><div class="line">Map由[:]定义，注意其中的冒号。冒号左边是key，右边是Value。key必须是字符串，value可以是任何对象。另外，key可以用&apos;&apos;或&quot;&quot;包起来，也可以不用引号包起来。比如</div><div class="line"></div><div class="line">def aNewMap = [key1:&quot;value&quot;,key2:true] //其中的key1和key2默认被</div><div class="line">处理成字符串&quot;key1&quot;和&quot;key2&quot;</div><div class="line"></div><div class="line">不过Key要是不使用引号包起来的话，也会带来一定混淆，比如</div><div class="line"></div><div class="line">def key1=&quot;wowo&quot;</div><div class="line">def aConfusedMap=[key1:&quot;who am i?&quot;]</div><div class="line"></div><div class="line">aConfuseMap中的key1到底是&quot;key1&quot;还是变量key1的值“wowo”？显然，答案是字符串&quot;key1&quot;。如果要是&quot;wowo&quot;的话，则aConfusedMap的定义必须设置成：</div><div class="line"></div><div class="line">def aConfusedMap=[(key1):&quot;who am i?&quot;]</div><div class="line"></div><div class="line">Map中元素的存取更加方便，它支持多种方法：</div><div class="line"></div><div class="line">println aMap.keyName    &lt;==这种表达方法好像key就是aMap的一个成员变量一样</div><div class="line">println aMap[&apos;keyName&apos;] &lt;==这种表达方法更传统一点</div><div class="line">aMap.anotherkey = &quot;i am map&quot;  &lt;==为map添加新元素</div></pre></td></tr></table></figure></p>
<p>  <strong>Range类</strong><br>  Range是Groovy对List的一种拓展，变量定义和大体的使用方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def aRange = 1..5  &lt;==Range类型的变量 由begin值+两个点+end值表示</div><div class="line">                      左边这个aRange包含1,2,3,4,5这5个值</div><div class="line"></div><div class="line">如果不想包含最后一个元素，则</div><div class="line"></div><div class="line">def aRangeWithoutEnd = 1..&lt;5  &lt;==包含1,2,3,4这4个元素</div><div class="line">println aRange.from</div><div class="line">println aRange.to</div></pre></td></tr></table></figure></p>
<p>  <strong>高级特性闭包</strong><br>  闭包，英文叫Closure，是Groovy中非常重要的一个数据类型或者说一种概念了。闭包的历史来源，种种好处我就不说了。我们直接看怎么使用它！闭包，是一种数据类型，它代表了一段可执行的代码。其外形如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def aClosure = &#123;//闭包是一段代码，所以需要用花括号括起来..  </div><div class="line">    String param1, int param2 -&gt;  //这个箭头很关键。箭头前面是参数定义，箭头后面是代码  </div><div class="line">    println&quot;this is code&quot; //这是代码，最后一句是返回值，  </div><div class="line">   //也可以使用return，和Groovy中普通函数一样  </div><div class="line">&#125;</div><div class="line">简而言之，Closure的定义格式是：</div><div class="line">def xxx = &#123;paramters -&gt; code&#125;  //或者  </div><div class="line">def xxx = &#123;无参数，纯code&#125;  这种case不需要-&gt;符号</div></pre></td></tr></table></figure></p>
<p>  说实话，从C/C++语言的角度看，闭包和函数指针很像。闭包定义好后，要调用它的方法就是：闭包对象.call(参数) 或者更像函数指针调用的方法：闭包对象(参数)比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">aClosure.call(&quot;this is string&quot;,100)  或者  </div><div class="line">aClosure(&quot;this is string&quot;, 100)</div><div class="line">\\上面就是一个闭包的定义和使用。在闭包中，还需要注意一点：</div><div class="line">\\如果闭包没定义参数的话，则隐含有一个参数，这个参数名字叫it，和this的作用类似。it代表闭包的参数。比如：</div><div class="line">def greeting = &#123; &quot;Hello, $it!&quot; &#125;</div><div class="line">assert greeting(&apos;Patrick&apos;) == &apos;Hello, Patrick!&apos;</div><div class="line">\\等同于</div><div class="line">def greeting = &#123; it -&gt; &quot;Hello, $it!&quot; &#125;</div><div class="line">assert greeting(&apos;Patrick&apos;) == &apos;Hello, Patrick!&apos;</div><div class="line">\\但是，如果在闭包定义时，采用下面这种写法，则表示闭包没有参数！</div><div class="line">def noParamClosure = &#123; -&gt; true &#125;</div><div class="line">\\这个时候，我们就不能给noParamClosure传参数了！</div><div class="line">noParamClosure (&quot;test&quot;)  \\&lt;==报错喔！</div></pre></td></tr></table></figure></p>
<p>  <strong>Closure使用中的注意点</strong><br>  <strong>1、省略圆括号</strong><br>  闭包在Groovy中大量使用，比如很多类都定义了一些函数，这些函数最后一个参数都是一个闭包。比如：<br><code>public static &lt;T&gt; List&lt;T&gt; each(List&lt;T&gt; self, Closure closure)</code><br>上面这个函数表示针对List的每一个元素都会调用closure做一些处理。这里的closure，就有点回调函数的感觉。但是，在使用这个each函数的时候，我们传递一个怎样的Closure进去呢？比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def iamList = [1,2,3,4,5]  //定义一个List</div><div class="line">iamList.each&#123;  //调用它的each，这段代码的格式看不懂了吧？each是个函数，圆括号去哪了? </div><div class="line">  println it</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  上面代码有两个知识点：each函数调用的圆括号不见了！原来，Groovy中，当函数的最后一个参数是闭包的话，可以省略圆括号。比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def  testClosure(int a1,String b1, Closure closure)&#123; </div><div class="line">     //do something     </div><div class="line">   closure() //调用闭包&#125;那么调用的时候，就可以免括号！</div><div class="line">   testClosure (4, &quot;test&quot;, &#123;   </div><div class="line">      println &quot;i am in closure&quot;</div><div class="line">    &#125; )  </div><div class="line">  //括号可以不写..</div></pre></td></tr></table></figure></p>
<p>  注意，这个特点非常关键，因为以后在Gradle中经常会出现图1这样的代码：<br><img src="http://upload-images.jianshu.io/upload_images/4002556-9954adc040e0ead9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img1"><br>  经常碰见图1这样的没有圆括号的代码。省略圆括号虽然使得代码简洁，看起来更像脚本语言，但是它这经常会让我confuse（不知道其他人是否有同感），以doLast为例，完整的代码应该按下面这种写法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">doLast(&#123;   </div><div class="line">println &apos;Hello world!&apos;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>  有了圆括号，你会知道 doLast只是把一个Closure对象传了进去。很明显，它不代表这段脚本解析到doLast的时候就会调用println ‘Hello world!’ 。但是把圆括号去掉后，就感觉好像println ‘Hello world!’立即就会被调用一样！<br>  <strong>2、如何确定Closure的参数</strong><br>  另外一个比较让人头疼的地方是，Closure的参数该怎么搞？还是刚才的each函数：<br> <code>public static &lt;T&gt; List&lt;T&gt; each(List&lt;T&gt; self, Closure closure)</code><br>如何使用它呢？比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">def iamList = [1,2,3,4,5]  //定义一个List变量</div><div class="line">iamList.each&#123;  //调用它的each函数，只要传入一个Closure就可以了。 </div><div class="line">   println it</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  看起来很轻松，其实：对于each所需要的Closure，它的参数是什么？有多少个参数？返回值是什么？我们能写成下面这样吗？<br><code>iamList.each{String name,int x -&gt;  return x}  //运行的时候肯定报错！</code><br>  所以，Closure虽然很方便，但是它一定会和使用它的上下文有极强的关联。要不，作为类似回调这样的东西，我如何知道调用者传递什么参数给Closure呢？<br>  此问题如何破解？只能通过查询API文档才能了解上下文语义。比如下图2：<br><img src="http://upload-images.jianshu.io/upload_images/4002556-dccb6b35ef067d78.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img2"><br><img src="http://upload-images.jianshu.io/upload_images/4002556-40f86f1d8aa68334.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img3"><br>  图2中：each函数说明中，将给指定的closure传递Set中的每一个item。所以，closure的参数只有一个。findAll中，绝对抓瞎了。一个是没说明往Closure里传什么。另外没说明Closure的返回值是什么…..。<br>  对Map的findAll而言，Closure可以有两个参数。findAll会将Key和Value分别传进去。并且，Closure返回true，表示该元素是自己想要的。返回false表示该元素不是自己要找的。示意代码所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def result = aMap.findAll &#123;   </div><div class="line">      key, value -&gt;        </div><div class="line">            println &quot;key=$key,value=$value&quot;       </div><div class="line">           if (key == &quot;k1&quot;)           </div><div class="line">                 return true       </div><div class="line">           return false</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  Closure的使用有点坑，很大程度上依赖于你对API的熟悉程度，所以最初阶段，SDK查询是少不了的。<br>  <strong>3、脚本类</strong><br>  groovy也可以像java那样写package，然后写类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">package bean</div><div class="line">class Person &#123;    </div><div class="line">  String name    </div><div class="line">  String gender    </div><div class="line">  Person(name, gender) &#123;</div><div class="line">        this.name = name        </div><div class="line">        this.gender = gender   </div><div class="line">   &#125;    </div><div class="line">  def print() &#123;</div><div class="line">        println name + &quot; &quot; + gender    </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<pre><code>import bean.Person
def name = &apos;EvilsoulM&apos;
def person=new Person(name,&quot;male&quot;);
person.print()
</code></pre><p>  groovy和Java类很相似。当然，如果不声明public/private等访问权限的话，Groovy中类及其变量默认都是public的。<br>  <strong>4、脚本到底是什么</strong><br>  Java中，我们最熟悉的是类。但是我们在Java的一个源码文件中，不能不写class（interface或者其他….），而Groovy可以像写脚本一样，把要做的事情都写在xxx.groovy中，而且可以通过groovy xxx.groovy直接执行这个脚本。这到底是怎么搞的？<br>  Groovy把它转换成这样的Java类：执行 <strong>groovyc</strong> -d classes test.groovy <strong>groovyc</strong>是groovy的编译命令，-d classes用于将编译得到的class文件拷贝到classes文件夹下图4是test.groovy脚本转换得到的java class。用jd-gui反编译它的代码：<br><img src="http://upload-images.jianshu.io/upload_images/4002556-814c8be6497129a9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img4"><br>  test.groovy被转换成了一个test类，它从script派生。</p>
<ul>
<li>每一个脚本都会生成一个static main函数。</li>
<li>这样，当我们groovy test.groovy的时候，其实就是用java去执行这个main函数脚本中的所有代码都会放到run函数中。比如，println ‘Groovy world’，这句代码实际上是包含在run函数里的。</li>
<li>如果脚本中定义了函数，则函数会被定义在test类中。</li>
</ul>
<p>  <strong>groovyc</strong>是一个比较好的命令，读者要掌握它的用法。然后利用jd-gui来查看对应class的Java源码。<br>  <strong>5、脚本中的变量和作用域</strong><br>  前面说了，xxx.groovy只要不是和Java那样的class，那么它就是一个脚本。而且脚本的代码其实都会被放到run函数中去执行。那么，在Groovy的脚本中，很重要的一点就是脚本中定义的<strong>变量和它的作用域</strong>。举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def x = 1  // &lt;==注意，这个x有def（或者指明类型，比如 int x = 1）</div><div class="line">def printx()&#123;     </div><div class="line">  println x  </div><div class="line">&#125;</div><div class="line">//printx() &lt;==报错，说x找不到</div></pre></td></tr></table></figure></p>
<p>  为什么？继续来看反编译后的class文件。<br><img src="http://upload-images.jianshu.io/upload_images/4002556-31d20df24196ba67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img5"><br>  图中，x也没有被定义成test的成员函数，而是在run的执行过程中，将x作为一个属性添加到test实例对象中了。然后在printx中，先获取这个属性。注意，Groovy的文档说 x = 1这种定义将使得x变成test的成员变量，但从反编译情况看，这是不对的…..(这是infoQ文章中说的，但是测试来说这句话是对的，应该是文章作者没有定义成class)虽然printx可以访问x变量了，但是假如有其他脚本却无法访问x变量。因为它不是test的成员变量。比如，我在测试目录下创建一个新的名为test1.groovy。这个test1将访问test.groovy中定义的printx函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def atest=new test()</div><div class="line">atest.printx()</div></pre></td></tr></table></figure></p>
<p>  这种方法使得我们可以将代码分成模块来编写，比如将公共的功能放到test.groovy中，然后使用公共功能的代码放到test1.groovy中。执行groovy test1.groovy，报错。说x找不到。这是因为x是在test的run函数动态加进去的。怎么办？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">import groovy.transform.Field;   //必须要先import</div><div class="line">@Field x = 1 // &lt;==在x前面加上@Field标注，这样，x就彻彻底底是test的成员变量了。</div></pre></td></tr></table></figure></p>
<p>查看编译后的test.class文件，得到：<br><img src="http://upload-images.jianshu.io/upload_images/4002556-99289c83801f4e88.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img6"><br>  这个时候，test.groovy中的x就成了test类的成员函数了。如此，我们可以在script中定义那些需要输出给外部脚本或类使用的变量了！<br>  eg:<br>  ScriptBase.groovy类 (用了filed 就相当这就是一个class 就不用再自己定义class了)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import groovy.transform.Field;</div><div class="line">@Field author = &apos;EvilsouM&apos;</div><div class="line">@Field gender = &apos;male&apos;</div><div class="line">@Field age = 25//必须要先import</div><div class="line">def printInfo() &#123;    </div><div class="line">println &quot;name-&gt;$author  gender-&gt;$gender age-&gt;$age&quot;</div><div class="line">&#125;</div><div class="line">//或者自己定义class</div><div class="line">class ScriptBase &#123;    </div><div class="line">  def author = &apos;EvilsouM&apos;    </div><div class="line">  def gender = &apos;male&apos;    </div><div class="line">  def age = 25//必须要先import    </div><div class="line">  def printInfo() &#123;        </div><div class="line">    println &quot;name-&gt;$author  gender-&gt;$gender age-&gt;$age&quot;    </div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>  .groovy类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def Closure printAuthorInfo = &#123;       </div><div class="line">     String name, String gender, int age -&gt;               </div><div class="line">                println &quot;name-&gt;$name  gender-&gt;$gender age-&gt;$age&quot;</div><div class="line">&#125;</div><div class="line">def ScriptBase base = new ScriptBase()</div><div class="line">base.printInfo()</div><div class="line">printAuthorInfo.call(base.author, base.gender, base.age) //上面两种方式都能拿到成员变量</div></pre></td></tr></table></figure></p>
<p>  <strong>文件I/O操作</strong><br>  本节介绍下Groovy的文件I/O操作。直接来看例子吧，虽然比Java看起来简单，但要理解起来其实比较难。尤其是当你要自己查SDK并编写代码的时候。整体说来，Groovy的I/O操作是在原有Java I/O操作上进行了更为简单方便的封装，并且使用Closure来简化代码编写。主要封装了如下一些了类：<br><img src="http://upload-images.jianshu.io/upload_images/4002556-28de37091817383d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img7">
  </p>
<ul>
<li><p>读文件Groovy中，文件读操作简单到令人发指：def targetFile = new File(文件名) &lt;==File对象还是要创建的。然后打开<a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/File.html</a>看看Groovy定义的API：</p>
<ul>
<li><p>读该文件中的每一行：eachLine的唯一参数是一个Closure。Closure的参数是文件每一行的内容其内部实现肯定是Groovy打开这个文件，然后读取文件的一行，然后调用Closure…</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def File targetFile = new File(&quot;build.gradle&quot;)</div><div class="line">targetFile.eachLine &#123;   </div><div class="line">   String line -&gt;       </div><div class="line">         println line</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>直接得到文件内容<br><code>targetFile.getBytes()  &lt;==文件内容一次性读出，返回类型为byte[]</code></p>
</li>
<li><p>使用InputStream.InputStream的SDK在 <a href="http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html" target="_blank" rel="external">http://docs.groovy-lang.org/latest/html/groovy-jdk/java/io/InputStream.html</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def ism =  targetFile.newInputStream()  //操作ism，最后记得关掉 </div><div class="line">ism.close</div></pre></td></tr></table></figure>
</li>
<li><p>使用闭包操作inputStream，以后在Gradle里会常看到这种搞法<br>``<br>targetFile.withInputStream{<br>ism -&gt; //操作ism. 不用close。Groovy会自动替你close<br>}</p>
</li>
</ul>
</li>
</ul>
<p>  <strong>写文件和读文件差不多</strong><br>  不再啰嗦。这里给个例子，告诉大家如何copy文件。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def srcFile = new File(源文件名)</div><div class="line">def targetFile = new File(目标文件名)</div><div class="line">targetFile.withOutputStream&#123;</div><div class="line">    os-&gt; </div><div class="line">        srcFile.withInputStream &#123;</div><div class="line">                ins-&gt;   </div><div class="line">                    os &lt;&lt; ins //利用OutputStream的&lt;&lt;操作符重载，完成从inputstream到OutputStream  //的输出  </div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上的知识点都可以去官网查看API，Groovy的API文档位于 <a href="http://www.groovy-lang.org/api.html" target="_blank" rel="external">http://www.groovy-lang.org/api.html</a></p>
<p>##第一个Gradle项目，领略Gradle的风采</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4002556-70dabeede1a39ea8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img8"></p>
<p>##Gradle构建脚步基本原理部分<br>  <strong>构建脚步介绍</strong><br>  Gradle构建中的两个基本概念就是项目（project)和任务（task),每个构建（build.gradle)至少包含一个项目，项目中包含一个或多个任务。在多项目构建中，一个项目可以依赖于其他项目；类似的，任务可以形成一个依赖关系图来确保他们的执行顺序。<br><img src="http://upload-images.jianshu.io/upload_images/4002556-d39c41efbf21130a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img9.png"></p>
<p>###脚步基本组成部分<br>  <strong>项目（project)</strong><br>  一个项目代表一个正在构建的组件（比如一个jar文件），当构建启动后，Gradle会基于build.gradle实例化一个<strong>org.gradle.api.Project</strong>类，并且能够通过project变量使其隐式可用。Project类的主要属性和方法<br>  <strong>属性group、name、version<br>  方法有apply、dependencies、repositories、task<br>  属性的其他配置方式：ext、gradle.properties</strong><br>  <strong>任务（task)</strong><br>  任务对应<strong>org.gradle.api.Task</strong>。主要包括任务动作和任务依赖。任务动作定义了一个最小的工作单元。可用定义依赖于其他任务、动作序列和执行条件。<br>  <strong>Task重要的方法<br>    dependsOn<br>    doFirst,doLast &lt;&lt; </strong><br>     task是个动作列，doFirst就是在动作列表最前面添加一个动作，doLast就是在动作列表的最后面添加一个动作<br><img src="http://upload-images.jianshu.io/upload_images/4002556-786f96e9bd674399.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img10"><br>    <strong>自定义任务（Task)、Task的生命周期</strong><br>    <strong>自定义创建文件夹任务</strong></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4002556-46e11ac89d210745.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img11"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4002556-f1b93640026f0e60.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img12"><br>  <strong>构建生命周期</strong><br>  1、 初始化阶段<br>  项目构建开始的时候，会根据build.gradle构建一个项目即project并且在这个脚本中隐式可用。在多项目构建中这个阶段也是很重要的，它会初始化所有需要参与到构建中的项目。<br>  2、配置阶段<br>  这个阶段就是遍历项目中所有task,生成task依赖顺序以及执行顺序，根据配置代码来生成的。配置代码就是除了动作代码外都是配置代码，可以简单的这么理解。 这个阶段相当于初始化任务Task阶段<br>  配置代码如：<br><img src="http://upload-images.jianshu.io/upload_images/4002556-b0ab13a3d52d94f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img13"><br>    3、执行阶段<br>  主要执行动作代码，执行完后即一个构建就完成了。<br>  动作代码如：<br><img src="http://upload-images.jianshu.io/upload_images/4002556-dba1903ba4a32f3b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img14"><br>  Gradle的工作流程其实蛮简单，用一个图15来表达：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4002556-e4489e6eb5e9e2b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img15"><br>  图15告诉我们，Gradle工作包含三个阶段：<br>  首先是初始化阶段。对我们前面的multi-project build而言，就是执行settings.gradle<br>  Initiliazation phase的下一个阶段是Configration阶段。<br>  Configration阶段的目标是解析每个project中的build.gradle。比如multi-project build例子中，解析每个子目录中的build.gradle。在这两个阶段之间，我们可以加一些定制化的Hook。这当然是通过API来添加的。Configuration阶段完了后，整个build的project以及内部的Task关系就确定了。恩？前面说过，一个Project包含很多Task，每个Task之间有依赖关系。Configuration会建立一个有向图来描述Task之间的依赖关系。所以，我们可以添加一个HOOK，即当Task关系图建立好后，执行一些操作。<br>  最后一个阶段就是执行任务了。当然，任务执行完后，我们还可以加Hook。<br> 我在：</p>
<ul>
<li>settings.gradle加了一个输出。</li>
<li>在posdevice的build.gradle加了图15中的beforeProject函数。</li>
<li>在CPosSystemSdk加了taskGraph whenReady函数和buidFinished函数。</li>
</ul>
<p>  好了，Hook的代码怎么写，估计你很好奇，而且肯定会埋汰，怎么就还没告诉我怎么写Gradle。马上了！<br>最后，关于Gradle的工作流程，你只要记住：</p>
<ul>
<li>Gradle有一个初始化流程，这个时候settings.gradle会执行。</li>
<li>在配置阶段，每个Project都会被解析，其内部的任务也会被添加到一个有向图里，用于解决执行过程中的依赖关系。</li>
<li>然后才是执行阶段。你在gradle xxx中指定什么任务，gradle就会将这个xxx任务链上的所有任务全部按依赖顺序执行一遍！<br>  下面的这个链接对于学习Gradle很重要，<br>  <a href="https://docs.gradle.org/current/dsl/" target="_blank" rel="external">https://docs.gradle.org/current/dsl/</a><br><strong>依赖管理</strong><br>  几乎所有的基于JVM软件项目都需要依赖外部类库来重用现有的功能。自动化依赖管理可以明确依赖的版本，可以解决因传递性依赖带来的版本冲突。<br>  <strong>工件坐标</strong><pre><code>group、name、version
</code></pre> <strong>  仓库</strong><pre><code>    mavenLocal/mavenCentral/jcenter，第一个本地仓库，后面两个是公共仓库
    自定义maven仓库，就是maven私服仓库，公司内部为了代码的安全肯定不会放到公共仓库里面去，我们需要搭建一个内部仓库，管理自己的jar包。这个是实际中经常用的。
     文件仓库，所谓的文件仓库，就是本地机器上的文件路径也可以作为仓库，这个非常不建议大家使用，因为我们使用构建工具就是为了让构建一致性，就是到处构建，结果应该是一样的。如果跟具体的机器有关的话，就违反了我们使用构建工具的初衷。 
**依赖的传递性**
     B依赖A，如果C依赖B，那么C依赖A 
     正是因为有这种依赖的传递性，造成版本的冲突
</code></pre></li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/4002556-a7836bf0815c32ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img16"><br>   <strong>依赖阶段配置</strong></p>
<ul>
<li>compile、runtime</li>
<li>testCompile、testRuntime</li>
</ul>
<p>    <strong>依赖阶段关系</strong><br><img src="http://upload-images.jianshu.io/upload_images/4002556-6159965d26f6cc91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img17"><br>   编译期依赖的，运行期必然依赖，运行期依赖的，编译期未必依赖；源码编译依赖的，测试编译必然依赖，测试编译依赖的，源码编译期未必依赖；测试编译依赖的，测试运行期必然依赖。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/4002556-41ee1a4a285aa3a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img18"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/4002556-7842199223dbb68c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img19"><br>  mavenCentral公共仓库网址<a href="http://search.maven.org/" target="_blank" rel="external">http://search.maven.org/</a><br><img src="http://upload-images.jianshu.io/upload_images/4002556-c4dd406ac07bbf42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img20"><br>  <strong> 版本冲突解决方法</strong><br>   版本冲突实际列子  </p>
<p><img src="http://upload-images.jianshu.io/upload_images/4002556-3b1fe9b40d6d1cbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img21"><br>   <strong>解决方法步骤</strong><br>   1、查看依赖报告<br>   2、排除传递性依赖<br>   3、强制制定一个版本<br>   基本不需要我们自己解决版本冲突，gradle会自动帮我们强制依赖最高版本的jar包<br>   修改默认解决策略方法，不然很难发现版本冲突<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  configurations.all&#123;</div><div class="line">    resolutionsStrategy&#123;</div><div class="line">        failOnVersionConflict()</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>   排除传递性依赖的方法如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">compile(&apos;org.hibernate:hibernate-core:3.6.3.Final&apos;)&#123;</div><div class="line">    exclude group:&quot;org.slf4j&quot;,module:&quot;slf4j-api&quot;</div><div class="line">    //transitive=false</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>   强制制定一个版本<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">  configurations.all&#123;</div><div class="line">    resolutionsStrategy&#123;</div><div class="line">        force &apos;org.slf4j:slf4j-api:1.7.24&apos;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>

                
<p class="pink-link-context">
    <a href="/2017/06/18/hello-world/" rel="next" title="Hello World">
    上一篇：Hello World
  </a>
</p>




            </div>
			
        </div>
    </div>
</article>




    <div id="cloud-tie-wrapper" class="cloud-tie-wrapper"></div>
    <script>
      var cloudTieConfig = {
        url: document.location.href,
        sourceId: "",
        productKey: "821f57ac036b40fa837ede0543654b58",
        target: "cloud-tie-wrapper"
      };
    </script>
    <script src="https://img1.cache.netease.com/f2e/tie/yun/sdk/loader.js"></script>



</div>

        <div class="fixed-action-btn float-sitemap">
    <a class="btn-floating btn-large pink">
      <i class="fa fa-caret-square-o-up"></i>
    </a>
    <ul>
      <li><a class="btn-return-top btn-floating waves-effect green" title="回到顶部"><i class="fa fa-arrow-circle-o-up"></i></a></li>
      <li><a class="btn-floating waves-effect button-collapse yellow darken-1"  data-activates="main-menu" title="菜单"><i class="fa fa-navicon"></i></a></li>
    </ul>
  </div>

    </main>
    <footer class="page-footer indigo darken-1">
    
    <div class="footer-container container">
        <div class="row">
            
            <div class="social-group col m4 s12">
                <h5 class="white-text">社交</h5>
                
                    <a class="social-link" href="http://weibo.com/u/3122370067" target="_blank">
                        <i class="fa fa-2x fa-weibo"></i>
                    </a>
                
                    <a class="social-link" href="https://github.com/yishiyushen" target="_blank">
                        <i class="fa fa-2x fa-github"></i>
                    </a>
                
                    <a class="social-link" href="/atom.xml" target="_blank">
                        <i class="fa fa-2x fa-rss"></i>
                    </a>
                
                
    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
    </script>
    <div class="site-visitors-container white-text">
        <span>
            <i class="fa fa-user"></i>
            <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
        </span>
        <span>&nbsp;|&nbsp;</span>
        <span>
            <i class="fa fa-eye"></i>
            <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
        </span>
    </div>


            </div>
            

            
            <div class="col m8 s12">
                <h5 class="white-text">友情链接</h5>
                
                    <a class="social-link" href="http://raytaylorlin.com/" target="_blank">raytaylorism主题作者的技术博客</a>
                
                    <a class="social-link" href="https://github.com/raytaylorlin" target="_blank">Github地址</a>
                
            </div>
            
        </div>
    </div>
    

    <div class="footer-copyright pink-link-context">
        <div class="container">
            © 2017 yishiyushen.github.io.com, All rights reserved.
            <p class="right" style="margin-top: 0;">本博客由 <a href="https://hexo.io">Hexo</a> 强力驱动 | 主题 <a href="https://github.com/raytaylorlin/hexo-theme-raytaylorism">raytaylorism</a></p>
        </div>
    </div>
</footer>


    <noscript>
    <div class="noscript">
        <p class="center-align">当前网速较慢或者你使用的浏览器不支持博客特定功能，请尝试刷新或换用Chrome、Firefox等现代浏览器</p>
    </div>
</noscript>
<div class="noscript">
    <p class="center-align">当前网速较慢或者你使用的浏览器不支持博客特定功能，请尝试刷新或换用Chrome、Firefox等现代浏览器</p>
</div>


<script src="/js/jquery.min.js"></script>
<script src="/js/materialize.min.js"></script>

<script>
    (function($) {
        $(document).ready(function() {
            // 隐藏禁用javascript（针对微信内置浏览器）的提示
            $('.noscript').hide();

            // 图片缩放效果
            var $imgs = $('img').not('.slider-image').not('.avatar-image').not('.carousel-image').not('.card-cover-image').not('.qrcode');

            // 给图片加上点击放大效果（materialbox插件）
            $imgs.addClass('materialboxed').each(function(i, el) {
                $(this).attr('data-caption', $(this).attr('alt') || ' ');
            }).materialbox();

            // 优化表格的显示
            $('table').each(function() {
                var $table = $(this);
                // 除去多行代码的情况
                if ($table.find('pre').length == 0) {
                    $table.addClass('responsive-table striped bordered');
                }
            });

            // 首页幻灯片
            $('.slider').slider({indicators: true, full_width: true, interval: 8000});

            $(".button-collapse").sideNav();
            $(".category-menu").sideNav();

            // 针对gallery post
            $('.carousel').carousel({full_width: true});
            $('.carousel-control.prev').click(function() {
                $('.carousel').carousel('prev');
            });
            $('.carousel-control.next').click(function() {
                $('.carousel').carousel('next');
            });

            // 文章目录
            $('article').not('.simple-article').find('h1').add('h2').add('h3').add('h4').add('h5').add('h6').scrollSpy();

            // 目录随屏幕滚动（防止目录过长越过footer）
            var $toc = $('.toc');
            var scrollTargetTop = 0;
            $(window).scroll(function() {
                var $activeLink = $toc.find('a.active.section');
                if ($(window).scrollTop() < 100) {
                    scrollTargetTop = 0;
                } else {
                    if ($activeLink[0]) {
                        scrollTargetTop = $activeLink.offset().top - $toc.offset().top;
                    }
                }
                $toc.css('top', '-' + scrollTargetTop + 'px');
            });

            // 修正文章目录的left-border颜色
            var color = $('.table-of-contents-text').css('color');
            $('.table-of-contents-link').css('border-left-color', color);

            // 针对移动端做的优化：FAB按钮点击一下收回
            if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)) {
                $('.fixed-action-btn').addClass('click-to-toggle');
            }
            // 回到顶部
            $('.btn-return-top').click(function() {
                $('body, html').animate({
                    scrollTop: 0
                }, 500);
            });

            // 重置读书页面的Tab标签页的颜色
            $('li.tab a').hover(function() {
                $(this).toggleClass('text-lighten-4');
            });
            $('.indicator').addClass('pink lighten-2');

            
            // 添加new标签
            $('').append('<span class="new badge pink"></span>');
            

            // 搜索功能
            $('.modal-trigger').leanModal({
                // 打开搜索框时自动聚焦
                ready: function() {
                    if ($('#search').is(":visible")) {
                        $('#search-input').focus();
                    }
                }
            });
            var searchXml = "";
            if (searchXml.length == 0) {
             	searchXml = "search.xml";
            }
            var searchPath = "/" + searchXml;
            initSearch(searchPath, 'search-input', 'search-result');
        });

        // 初始化搜索与匹配函数
        var initSearch = function(path, search_id, content_id) {
            'use strict';
            $.ajax({
                url: path,
                dataType: "xml",
                success: function(xmlResponse) {
                    // get the contents from search data
                    var datas = $("entry", xmlResponse).map(function() {
                        return {
                            title: $("title", this).text(),
                            content: $("content", this).text(),
                            url: $("url", this).text()
                        };
                    }).get();
                    var $input = document.getElementById(search_id);
                    var $resultContent = document.getElementById(content_id);
                    $input.addEventListener('input', function() {
                        var str = '<ul class=\"search-result-list\">';
                        var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                        $resultContent.innerHTML = "";
                        if (this.value.trim().length <= 0) {
                            return;
                        }
                        // perform local searching
                        datas.forEach(function(data) {
                            var isMatch = true;
                            var content_index = [];
                            var data_title = data.title.trim().toLowerCase();
                            var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                            var data_url = data.url;
                            var index_title = -1;
                            var index_content = -1;
                            var first_occur = -1;
                            // only match artiles with not empty titles and contents
                            if (data_title != '' && data_content != '') {
                                keywords.forEach(function(keyword, i) {
                                    index_title = data_title.indexOf(keyword);
                                    index_content = data_content.indexOf(keyword);
                                    if (index_title < 0 && index_content < 0) {
                                        isMatch = false;
                                    } else {
                                        if (index_content < 0) {
                                            index_content = 0;
                                        }
                                        if (i == 0) {
                                            first_occur = index_content;
                                        }
                                    }
                                });
                            }
                            // show search results
                            if (isMatch) {
                                keywords.forEach(function(keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    data_title = data_title.replace(regS, "<span class=\"search-keyword pink lighten-2\">" + keyword + "</span>");
                                });

                                str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                                var content = data.content.trim().replace(/<[^>]+>/g, "");
                                if (first_occur >= 0) {
                                    // cut out 100 characters
                                    var start = first_occur - 20;
                                    var end = first_occur + 80;
                                    if (start < 0) {
                                        start = 0;
                                    }
                                    if (start == 0) {
                                        end = 100;
                                    }
                                    if (end > content.length) {
                                        end = content.length;
                                    }
                                    var match_content = content.substring(start, end);
                                    // highlight all keywords
                                    keywords.forEach(function(keyword) {
                                        var regS = new RegExp(keyword, "gi");
                                        match_content = match_content.replace(regS, "<span class=\"search-keyword pink lighten-2\">" + keyword + "</span>");
                                    });

                                    str += "<p class=\"search-result\">..." + match_content + "...</p>"
                                }
                                str += "</li>";
                            }
                        });
                        str += "</ul>";
                        $resultContent.innerHTML = str;
                    });
                }
            });
        }
    })(jQuery);
</script>


<script src="/js/prettify.js"></script>
<script type="text/javascript">
    $(document).ready(function() {
        $("pre").addClass("prettyprint");
        prettyPrint();
    });
</script>




<script type="text/javascript" src="http://tajs.qq.com/stats?sId=62651788" charset="UTF-8"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
});
</script>
<script type="text/javascript" async
  src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>



</body>
</html>
